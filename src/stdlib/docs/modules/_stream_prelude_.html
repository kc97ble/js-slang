<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>&quot;stream.prelude&quot; | js-slang</title>
	<meta name="description" content="Documentation for js-slang">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../assets/js/search.json" data-base="..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../index.html" class="title">js-slang</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="../index.html">Globals</a>
				</li>
				<li>
					<a href="_stream_prelude_.html">&quot;stream.prelude&quot;</a>
				</li>
			</ul>
			<h1>Module &quot;stream.prelude&quot;</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<section class="tsd-panel tsd-comment">
				<div class="tsd-comment tsd-typography">
					<div class="lead">
						<p>This file defines prelude of streams, where includes 17 functions for streams.</p>
					</div>
				</div>
			</section>
			<section class="tsd-panel-group tsd-index-group">
				<h2>Index</h2>
				<section class="tsd-panel tsd-index-panel">
					<div class="tsd-index-content">
						<section class="tsd-index-section ">
							<h3>Variables</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-variable tsd-parent-kind-module"><a href="_stream_prelude_.html#streamprelude" class="tsd-kind-icon">stream<wbr>Prelude</a></li>
							</ul>
						</section>
					</div>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group ">
				<h2>Variables</h2>
				<section class="tsd-panel tsd-member tsd-kind-variable tsd-parent-kind-module">
					<a name="streamprelude" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagConst">Const</span> stream<wbr>Prelude</h3>
					<div class="tsd-signature tsd-kind-icon">stream<wbr>Prelude<span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">"// Supporting streams in the Scheme style, following// &quot;stream discipline&quot;// is_stream recurses down the stream and checks that it ends with the// empty list nullfunction is_stream(xs) {return is_null(xs) || (is_pair(xs) &amp;&amp; is_stream(stream_tail(xs)));}// A stream is either null or a pair whose tail is// a nullary function that returns a stream.function list_to_stream(xs) {return is_null(xs)? null: pair(head(xs),() &#x3D;&gt; list_to_stream(tail(xs)));}// stream_to_list transforms a given stream to a list// Lazy? No: stream_to_list needs to force the whole streamfunction stream_to_list(xs) {return is_null(xs)? null: pair(head(xs), stream_to_list(stream_tail(xs)));}// stream_length returns the length of a given argument stream// throws an exception if the argument is not a stream// Lazy? No: The function needs to explore the whole streamfunction stream_length(xs) {return is_null(xs)? 0: 1 + stream_length(stream_tail(xs));}// stream_map applies first arg f to the elements of the second// argument, assumed to be a stream.// f is applied element-by-element:// stream_map(f,list_to_stream(list(1,2)) results in// the same as list_to_stream(list(f(1),f(2)))// stream_map throws an exception if the second argument is not a// stream, and if the second argument is a non-empty stream and the// first argument is not a function.// Lazy? Yes: The argument stream is only explored as forced by//            the result stream.function stream_map(f, s) {return is_null(s)? null: pair(f(head(s)),() &#x3D;&gt; stream_map(f, stream_tail(s)));}// build_stream takes a non-negative integer n as first argument,// and a function fun as second argument.// build_list returns a stream of n elements, that results from// applying fun to the numbers from 0 to n-1.// Lazy? Yes: The result stream forces the applications of fun//            for the next elementfunction build_stream(n, fun) {function build(i) {return i &gt;&#x3D; n? null: pair(fun(i),() &#x3D;&gt; build(i + 1));}return build(0);}// stream_for_each applies first arg fun to the elements of the stream// passed as second argument. fun is applied element-by-element:// for_each(fun,list_to_stream(list(1, 2,null))) results in the calls fun(1)// and fun(2).// stream_for_each returns true.// stream_for_each throws an exception if the second argument is not a// stream, and if the second argument is a non-empty stream and the// first argument is not a function.// Lazy? No: stream_for_each forces the exploration of the entire streamfunction stream_for_each(fun, xs) {if (is_null(xs)) {return true;} else {fun(head(xs));return stream_for_each(fun, stream_tail(xs));}}// stream_reverse reverses the argument stream// stream_reverse throws an exception if the argument is not a stream.// Lazy? No: stream_reverse forces the exploration of the entire streamfunction stream_reverse(xs) {function rev(original, reversed) {return is_null(original)? reversed: rev(stream_tail(original),pair(head(original), () &#x3D;&gt; reversed));}return rev(xs, null);}// stream_append appends first argument stream and second argument stream.// In the result, null at the end of the first argument stream// is replaced by the second argument stream// stream_append throws an exception if the first argument is not a// stream.// Lazy? Yes: the result stream forces the actual append operationfunction stream_append(xs, ys) {return is_null(xs)? ys: pair(head(xs),() &#x3D;&gt; stream_append(stream_tail(xs), ys));}// stream_member looks for a given first-argument element in a given// second argument stream. It returns the first postfix substream// that starts with the given element. It returns null if the// element does not occur in the stream// Lazy? Sort-of: stream_member forces the stream only until the element is found.function stream_member(x, s) {return is_null(s)? null: head(s) &#x3D;&#x3D;&#x3D; x? s: stream_member(x, stream_tail(s));}// stream_remove removes the first occurrence of a given first-argument element// in a given second-argument list. Returns the original list// if there is no occurrence.// Lazy? Yes: the result stream forces the construction of each next elementfunction stream_remove(v, xs) {return is_null(xs)? null: v &#x3D;&#x3D;&#x3D; head(xs)? stream_tail(xs): pair(head(xs),() &#x3D;&gt; stream_remove(v, stream_tail(xs)));}// stream_remove_all removes all instances of v instead of just the first.// Lazy? Yes: the result stream forces the construction of each next elementfunction stream_remove_all(v, xs) {return is_null(xs)? null: v &#x3D;&#x3D;&#x3D; head(xs)? stream_remove_all(v, stream_tail(xs)): pair(head(xs), () &#x3D;&gt; stream_remove_all(v, stream_tail(xs)));}// filter returns the substream of elements of given stream s// for which the given predicate function p returns true.// Lazy? Yes: The result stream forces the construction of//            each next element. Of course, the construction//            of the next element needs to go down the stream//            until an element is found for which p holds.function stream_filter(p, s) {return is_null(s)? null: p(head(s))? pair(head(s),() &#x3D;&gt; stream_filter(p, stream_tail(s))): stream_filter(p, stream_tail(s));}// enumerates numbers starting from start,// using a step size of 1, until the number// exceeds end.// Lazy? Yes: The result stream forces the construction of//            each next elementfunction enum_stream(start, end) {return start &gt; end? null: pair(start,() &#x3D;&gt; enum_stream(start + 1, end));}// integers_from constructs an infinite stream of integers// starting at a given number n// Lazy? Yes: The result stream forces the construction of//            each next elementfunction integers_from(n) {return pair(n,() &#x3D;&gt; integers_from(n + 1));}// eval_stream constructs the list of the first n elements// of a given stream s// Lazy? Sort-of: eval_stream only forces the computation of//                the first n elements, and leaves the rest of//                the stream untouched.function eval_stream(s, n) {return n &#x3D;&#x3D;&#x3D; 0? null: pair(head(s),eval_stream(stream_tail(s),n - 1));}// Returns the item in stream s at index n (the first item is at position 0)// Lazy? Sort-of: stream_ref only forces the computation of//                the first n elements, and leaves the rest of//                the stream untouched.function stream_ref(s, n) {return n &#x3D;&#x3D;&#x3D; 0? head(s): stream_ref(stream_tail(s), n - 1);}"</span><span class="tsd-signature-symbol"> = &#x60;// Supporting streams in the Scheme style, following// &quot;stream discipline&quot;// is_stream recurses down the stream and checks that it ends with the// empty list nullfunction is_stream(xs) {return is_null(xs) || (is_pair(xs) &amp;&amp; is_stream(stream_tail(xs)));}// A stream is either null or a pair whose tail is// a nullary function that returns a stream.function list_to_stream(xs) {return is_null(xs)? null: pair(head(xs),() &#x3D;&gt; list_to_stream(tail(xs)));}// stream_to_list transforms a given stream to a list// Lazy? No: stream_to_list needs to force the whole streamfunction stream_to_list(xs) {return is_null(xs)? null: pair(head(xs), stream_to_list(stream_tail(xs)));}// stream_length returns the length of a given argument stream// throws an exception if the argument is not a stream// Lazy? No: The function needs to explore the whole streamfunction stream_length(xs) {return is_null(xs)? 0: 1 + stream_length(stream_tail(xs));}// stream_map applies first arg f to the elements of the second// argument, assumed to be a stream.// f is applied element-by-element:// stream_map(f,list_to_stream(list(1,2)) results in// the same as list_to_stream(list(f(1),f(2)))// stream_map throws an exception if the second argument is not a// stream, and if the second argument is a non-empty stream and the// first argument is not a function.// Lazy? Yes: The argument stream is only explored as forced by//            the result stream.function stream_map(f, s) {return is_null(s)? null: pair(f(head(s)),() &#x3D;&gt; stream_map(f, stream_tail(s)));}// build_stream takes a non-negative integer n as first argument,// and a function fun as second argument.// build_list returns a stream of n elements, that results from// applying fun to the numbers from 0 to n-1.// Lazy? Yes: The result stream forces the applications of fun//            for the next elementfunction build_stream(n, fun) {function build(i) {return i &gt;&#x3D; n? null: pair(fun(i),() &#x3D;&gt; build(i + 1));}return build(0);}// stream_for_each applies first arg fun to the elements of the stream// passed as second argument. fun is applied element-by-element:// for_each(fun,list_to_stream(list(1, 2,null))) results in the calls fun(1)// and fun(2).// stream_for_each returns true.// stream_for_each throws an exception if the second argument is not a// stream, and if the second argument is a non-empty stream and the// first argument is not a function.// Lazy? No: stream_for_each forces the exploration of the entire streamfunction stream_for_each(fun, xs) {if (is_null(xs)) {return true;} else {fun(head(xs));return stream_for_each(fun, stream_tail(xs));}}// stream_reverse reverses the argument stream// stream_reverse throws an exception if the argument is not a stream.// Lazy? No: stream_reverse forces the exploration of the entire streamfunction stream_reverse(xs) {function rev(original, reversed) {return is_null(original)? reversed: rev(stream_tail(original),pair(head(original), () &#x3D;&gt; reversed));}return rev(xs, null);}// stream_append appends first argument stream and second argument stream.// In the result, null at the end of the first argument stream// is replaced by the second argument stream// stream_append throws an exception if the first argument is not a// stream.// Lazy? Yes: the result stream forces the actual append operationfunction stream_append(xs, ys) {return is_null(xs)? ys: pair(head(xs),() &#x3D;&gt; stream_append(stream_tail(xs), ys));}// stream_member looks for a given first-argument element in a given// second argument stream. It returns the first postfix substream// that starts with the given element. It returns null if the// element does not occur in the stream// Lazy? Sort-of: stream_member forces the stream only until the element is found.function stream_member(x, s) {return is_null(s)? null: head(s) &#x3D;&#x3D;&#x3D; x? s: stream_member(x, stream_tail(s));}// stream_remove removes the first occurrence of a given first-argument element// in a given second-argument list. Returns the original list// if there is no occurrence.// Lazy? Yes: the result stream forces the construction of each next elementfunction stream_remove(v, xs) {return is_null(xs)? null: v &#x3D;&#x3D;&#x3D; head(xs)? stream_tail(xs): pair(head(xs),() &#x3D;&gt; stream_remove(v, stream_tail(xs)));}// stream_remove_all removes all instances of v instead of just the first.// Lazy? Yes: the result stream forces the construction of each next elementfunction stream_remove_all(v, xs) {return is_null(xs)? null: v &#x3D;&#x3D;&#x3D; head(xs)? stream_remove_all(v, stream_tail(xs)): pair(head(xs), () &#x3D;&gt; stream_remove_all(v, stream_tail(xs)));}// filter returns the substream of elements of given stream s// for which the given predicate function p returns true.// Lazy? Yes: The result stream forces the construction of//            each next element. Of course, the construction//            of the next element needs to go down the stream//            until an element is found for which p holds.function stream_filter(p, s) {return is_null(s)? null: p(head(s))? pair(head(s),() &#x3D;&gt; stream_filter(p, stream_tail(s))): stream_filter(p, stream_tail(s));}// enumerates numbers starting from start,// using a step size of 1, until the number// exceeds end.// Lazy? Yes: The result stream forces the construction of//            each next elementfunction enum_stream(start, end) {return start &gt; end? null: pair(start,() &#x3D;&gt; enum_stream(start + 1, end));}// integers_from constructs an infinite stream of integers// starting at a given number n// Lazy? Yes: The result stream forces the construction of//            each next elementfunction integers_from(n) {return pair(n,() &#x3D;&gt; integers_from(n + 1));}// eval_stream constructs the list of the first n elements// of a given stream s// Lazy? Sort-of: eval_stream only forces the computation of//                the first n elements, and leaves the rest of//                the stream untouched.function eval_stream(s, n) {return n &#x3D;&#x3D;&#x3D; 0? null: pair(head(s),eval_stream(stream_tail(s),n - 1));}// Returns the item in stream s at index n (the first item is at position 0)// Lazy? Sort-of: stream_ref only forces the computation of//                the first n elements, and leaves the rest of//                the stream untouched.function stream_ref(s, n) {return n &#x3D;&#x3D;&#x3D; 0? head(s): stream_ref(stream_tail(s), n - 1);}&#x60;</span></div>
					<aside class="tsd-sources">
						<ul>
							<li>Defined in home/spring/Documents/js-slang/src/stdlib/stream.prelude.ts:25</li>
						</ul>
					</aside>
					<div class="tsd-comment tsd-typography">
						<div class="lead">
							<p><code>is_stream(xs)</code>: Checks if <code>xs</code> is a stream.<br/>
								<code>list_to_stream(xs)</code>: Returns a stream from list <code>xs</code>.<br/>
								<code>stream_to_list(xs)</code>: Returns a list from stream <code>xs</code>.<br/>
								<code>stream_length(xs)</code>: Returns length of stream <code>xs</code>.<br/>
								<code>stream_map(f, s)</code>: Applies function <code>f</code> to each element of stream <code>s</code> and return the new stream.<br/>
								<code>build_stream(n, fun)</code>: Returns a stream with length <code>n</code> that results from apply <code>fun</code> from 0 to n-1.<br/>
								<code>stream_for_each(fun, xs)</code>: Applies <code>fun</code> on each element of stream <code>xs</code> element by element.<br/>
								<code>stream_reverse(xs)</code>: Returns the reverse the stream <code>xs</code>.<br/>
								<code>stream_append(xs, ys)</code>: Appends <code>ys</code> on stream <code>xs</code>.<br/>
								<code>stream_member(x, s)</code>: Checks if <code>x</code> is in stream <code>s</code>.<br/>
								<code>stream_remove(v, xs)</code>: Removes the first occurrence of <code>v</code> from stream <code>xs</code>.<br/>
								<code>stream_remove_all(v, xs)</code>: Removes all instances of <code>v</code> from stream <code>xs</code>.<br/>
								<code>stream_filter(p, s)</code>: Returns substream of stream <code>s</code> with elements that make predicate function <code>p</code> return <code>true</code>.<br/>
								<code>enum_stream(start, end)</code>: Returns a stream of enumeration of number from <code>start</code> to <code>end</code> with step size of 1.<br/>
								<code>integers_from(n)</code>: Returns a infinite stream of integers from <code>n</code>.<br/>
								<code>eval_stream(s, n)</code>: Returns a list only with first <code>n</code> elements of stream <code>s</code>.<br/>
							<code>stream_ref(s, n)</code>: Returns the element in stream <code>s</code> at index <code>n</code> (for first element, index is 0).<br/></p>
						</div>
					</div>
				</section>
			</section>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="../index.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_inspector_.html">&quot;inspector&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_list_.html">&quot;list&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_list_prelude_.html">&quot;list.prelude&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_misc_.html">&quot;misc&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_object_.html">&quot;object&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_parser_.html">&quot;parser&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_stream_.html">&quot;stream&quot;</a>
					</li>
					<li class="current tsd-kind-module">
						<a href="_stream_prelude_.html">&quot;stream.prelude&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_thunk_list_.html">&quot;thunk-<wbr>list&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="_thunk_stream_.html">&quot;thunk-<wbr>stream&quot;</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-variable tsd-parent-kind-module">
						<a href="_stream_prelude_.html#streamprelude" class="tsd-kind-icon">stream<wbr>Prelude</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="../assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="../assets/js/search.js"><' + '/script>');</script>
</body>
</html>